<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
<h1>hello world</h1>
<div id = "root"></div>
<script>
    let target = {
        name: 'Tom',
        age: 24
    }
    let handler = {
        get: function(target, key) {
            console.log('getting '+key);
            return target[key]; // 不是target.key
        },
        set: function(target, key, value) {
            console.log('setting '+key);
            target[key] = value;
        }
    }
    let proxy = new Proxy(target, handler)
    proxy.name     // 实际执行 handler.get
    proxy.age = 25 // 实际执行 handler.set
    // getting name
    // setting age
    // 25

    // target 可以为空对象
    let targetEpt = {}
    let proxyEpt = new Proxy(targetEpt, handler)
    // 调用 get 方法，此时目标对象为空，没有 name 属性
    proxyEpt.name // getting name
    // 调用 set 方法，向目标对象中添加了 name 属性
    proxyEpt.name = 'Tom'
    // setting name
    // "Tom"
    // 再次调用 get ，此时已经存在 name 属性
    proxyEpt.name
    // getting name
    // "Tom"

    // 通过构造函数新建实例时其实是对目标对象进行了浅拷贝，因此目标对象与代理对象会互相
    // 影响
    targetEpt
    // {name: "Tom"}

    // handler 对象也可以为空，相当于不设置拦截操作，直接访问目标对象
    let targetEmpty = {}
    let proxyEmpty = new Proxy(targetEmpty,{})
    proxyEmpty.name = "Tom"
    targetEmpty // {name: "Tom"}

    console.log("proxy=",proxy)
    console.log("proxyEpt=",proxyEpt)
    console.log("targetEmpty=",targetEmpty)


    //实例方法
    let exam ={
        name: "Tom",
        age: 24
    }
    let proxy1 = new Proxy(exam, {
        get(target, propKey, receiver) {
            console.log('Getting ' + propKey);
            return target[propKey];
        }
    })
    proxy1.name
    // Getting name
    // "Tom"


    //get() 方法可以继承。

    let proxys = new Proxy({}, {
    get(target, propKey, receiver) {
        // 实现私有属性读取保护
        if(propKey[0] === '_'){
            throw new Erro(`Invalid attempt to get private     "${propKey}"`);
        }
        console.log('Getting ' + propKey);
        return target[propKey];
        }
    });

    let obj = Object.create(proxys);
    obj.name = "cs"
    obj.age = "22"
    // Getting name
    console.log("========================================")
    console.log("obj.name",obj.name)//Getting age
    console.log("obj.age",obj.age)//obj.age undefined


    //用于拦截 target 对象上的 propKey 的赋值操作。如果目标对象自身的某个属性，不可写且不可配置，那么set方法将不起作用。
    let validator = {
        set: function(obj, prop, value) {
            if (prop === 'age') {
                if (!Number.isInteger(value)) {
                    throw new TypeError('The age is not an integer');
                }
                if (value > 200) {
                    throw new RangeError('The age seems invalid');
                }
            }
            // 对于满足条件的 age 属性以及其他属性，直接保存
            obj[prop] = value;
        }
    };
    let proxy3= new Proxy({}, validator)
    proxy3.age = 100;
    proxy3.age           // 100
    //proxy3.age = 'oppps' // 报错
    //proxy3.age = 300     // 报错


    //第四个参数 receiver 表示原始操作行为所在对象，一般是 Proxy 实例本身。
    const handler1 = {
        set: function(obj, prop, value, receiver) {
            obj[prop] = receiver;
        }
    };
    const proxy4 = new Proxy({}, handler1);
    proxy4.name= 'Tom';
    proxy4.name=== proxy // true

    const exam = {}
    Object.setPrototypeOf(exam, proxy4)
    exam.name = "Tom"
    exam.name === exam // true
</script>
</body>
</html>
