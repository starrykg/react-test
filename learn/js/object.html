<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
<h1>proxy</h1>
<div id = "root"></div>
<script>
    const age = 12;
    const name = "Amy";
    const person = {age, name};
    person   //{age: 12, name: "Amy"}
    //等同于
    const person3 = {age: age, name: name}

    const person2 = {
        sayHi(){
            console.log("Hi");
        }
    }
    person2.sayHi();  //"Hi"
    //等同于
    const person1 = {
        sayHi:function(){
            console.log("Hi");
        }
    }
    person1.sayHi();//"Hi"


    //如果是Generator 函数，则要在前面加一个星号:

    const obj = {
        * myGenerator() {
                yield 'hello world';
        }
    };
    //等同于
    const obj2 = {
        myGenerator: function* () {
            yield 'hello world';
        }
    };

    //ES6允许用表达式作为属性名，但是一定要将表达式放在方括号内。

    const obj1 = {
        hello(){
            return "hello";
        }
    }
    console.log("11111111111",obj.myGenerator());  //"hello"
    console.log("11111111111",obj1.hello());  //"hello"


    //属性的简洁表示法和属性名表达式不能同时使用，否则会报错。

/*
    const hello = "Hello";
    const obj3 = {
        [hello]
    };
    obj3  //SyntaxError: Unexpected token }
*/

    const hello = "Hello";
    const obj4 = {
        [hello+"2"]:"world"
    };
    obj4  //{Hello2: "world"}


    //对象的拓展运算符
    //拓展运算符（...）用于取出参数对象所有可遍历属性然后拷贝到当前对象。
    let person11 = {name: "Amy", age: 15};
    let someone = { ...person11 };
    someone;  //{name: "Amy", age: 15}
    console.log("someone",someone);

    //自定义的属性和拓展运算符对象里面属性的相同的时候：自定义的属性在拓展运算符后面，则拓展运算符对象内部同名的属性将被覆盖掉。
    let age1 = {age: 15};
    let name1 = {name: "Amy"};
    let person22 = {...age1, ...name1};
    person22;  //{age: 15, name: "Amy"}
    console.log("person22",person22);
    //自定义的属性在拓展运算度前面，则变成设置新对象默认属性值。
    let person33 = {name: "Amy", age: 15};
    let someone44 = {name: "Mike", age: 17, ...person33};
    someone44;  //{name: "Amy", age: 15}

    let target = {a: 1};
    let object2 = {b: 2};
    let object3 = {c: 3};
    Object.assign(target,object2,object3);
    // 第一个参数是目标对象，后面的参数是源对象
    target;  // {a: 1, b: 2, c: 3

    //因为 null 和 undefined 不能转化为对象，所以会报错:
    //Object.assign(null);       // TypeError: Cannot convert undefined or null to object
    //Object.assign(undefined);  // TypeError: Cannot convert undefined or null to object
    //当参数不止一个时，null 和 undefined 不放第一个，即不为目标对象时，会跳过 null 和 undefined ，不报错
    Object.assign(1,undefined);  // Number {1}
    Object.assign({a: 1},null);  // {a: 1}

    //Object.assign(undefined,{a: 1});  // TypeError: Cannot convert undefined or null to object

    //assign 的属性拷贝是浅拷贝:
    let sourceObj = { a: { b: 1}};
    let targetObj = {c: 3};
    Object.assign(targetObj, sourceObj);
    targetObj.a.b = 2;
    sourceObj.a.b;  // 2

    //同名属性替换
    targetObj = { a: { b: 1, c:2}};
    sourceObj = { a: { b: "hh"}};
    Object.assign(targetObj, sourceObj);
    targetObj;  // {a: {b: "hh"}}

    //数组的处理
    Object.assign([2,3], [5]);  // [5,3]

    //Object.is(value1, value2)
    //用来比较两个值是否严格相等，与（===）基本类似。
    Object.is("q","q");      // true
    Object.is(1,1);          // true
    Object.is([1],[1]);      // false
    Object.is({q:1},{q:1});  // false

    //与（===）的区别
    Object.is(+0,-0);  //false
    +0 === -0  //true
    //二是NaN等于本身
    Object.is(NaN,NaN); //true
    NaN === NaN  //false

</script>
</body>
</html>
