<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
<h1>proxy</h1>
<div id = "root"></div>
<script>
    let target = {
        name: 'Tom',
        age: 24
    }
    let handler = {
        get: function(target, key) {
            console.log('getting '+key);
            return target[key]; // 不是target.key
        },
        set: function(target, key, value) {
            console.log('setting '+key);
            target[key] = value;
        }
    }
    let proxy = new Proxy(target, handler)
    proxy.name     // 实际执行 handler.get
    proxy.age = 25 // 实际执行 handler.set
    // getting name
    // setting age
    // 25

    // target 可以为空对象
    let targetEpt = {}
    let proxyEpt = new Proxy(targetEpt, handler)
    // 调用 get 方法，此时目标对象为空，没有 name 属性
    proxyEpt.name // getting name
    // 调用 set 方法，向目标对象中添加了 name 属性
    proxyEpt.name = 'Tom'
    // setting name
    // "Tom"
    // 再次调用 get ，此时已经存在 name 属性
    proxyEpt.name
    // getting name
    // "Tom"

    // 通过构造函数新建实例时其实是对目标对象进行了浅拷贝，因此目标对象与代理对象会互相
    // 影响
    targetEpt
    // {name: "Tom"}

    // handler 对象也可以为空，相当于不设置拦截操作，直接访问目标对象
    let targetEmpty = {}
    let proxyEmpty = new Proxy(targetEmpty,{})
    proxyEmpty.name = "Tom"
    targetEmpty // {name: "Tom"}

    console.log("proxy=",proxy)
    console.log("proxyEpt=",proxyEpt)
    console.log("targetEmpty=",targetEmpty)


    //实例方法
    let exam ={
        name: "Tom",
        age: 24
    }
    let proxy1 = new Proxy(exam, {
        get(target, propKey, receiver) {
            console.log('Getting ' + propKey);
            return target[propKey];
        }
    })
    proxy1.name
    // Getting name
    // "Tom"


    //get() 方法可以继承。

    let proxys = new Proxy({}, {
    get(target, propKey, receiver) {
        // 实现私有属性读取保护
        if(propKey[0] === '_'){
            throw new Erro(`Invalid attempt to get private     "${propKey}"`);
        }
        console.log('Getting ' + propKey);
        return target[propKey];
        }
    });

    let obj = Object.create(proxys);
    obj.name = "cs"
    obj.age = "22"
    // Getting name
    console.log("========================================")
    console.log("obj.name",obj.name)//Getting age
    console.log("obj.age",obj.age)//obj.age undefined


    //用于拦截 target 对象上的 propKey 的赋值操作。如果目标对象自身的某个属性，不可写且不可配置，那么set方法将不起作用。
    let validator = {
        set: function(obj, prop, value) {
            if (prop === 'age') {
                if (!Number.isInteger(value)) {
                    throw new TypeError('The age is not an integer');
                }
                if (value > 200) {
                    throw new RangeError('The age seems invalid');
                }
            }
            // 对于满足条件的 age 属性以及其他属性，直接保存
            obj[prop] = value;
        }
    };
    let proxy3= new Proxy({}, validator)
    proxy3.age = 100;
    proxy3.age           // 100
    //proxy3.age = 'oppps' // 报错
    //proxy3.age = 300     // 报错


    //第四个参数 receiver 表示原始操作行为所在对象，一般是 Proxy 实例本身。
    const handler1 = {
        set: function(obj, prop, value, receiver) {
            obj[prop] = receiver;
        }
    };
    const proxy4 = new Proxy({}, handler1);
    proxy4.name= 'Tom';
    proxy4.name=== proxy // true

    const exam1 = {}
    Object.setPrototypeOf(exam1, proxy4)
    exam1.name = "Tom"
    exam1.name === exam1 // true
    console.log("exam1.name",exam1.name)
    console.log("exam1",exam1)



    //用于拦截函数的调用、call 和 reply 操作。target 表示目标对象，ctx 表示目标对象上下文，args 表示目标对象的参数数组。
    function sub(a, b){
        return a - b;
    }
    let handler2 = {
        apply: function(target, ctx, args){
            console.log('handle apply');
            console.log('...arguments',...arguments);
            console.log('Reflect.apply(...arguments)',Reflect.apply(...arguments));
            return Reflect.apply(...arguments);
        }
    }
    let proxy5 = new Proxy(sub, handler2)
    let num =  proxy5(2, 1)
    console.log('num = ',num);
    // handle apply
    // 1

    //用于拦截 HasProperty 操作，即在判断 target 对象是否存在 propKey 属性时，
    // 会被这个方法拦截。此方法不判断一个属性是对象自身的属性，还是继承的属性。
    let  handler3 = {
        has: function(target, propKey){
            console.log("handle has");
            return propKey in target;
        }
    }
    let exam2 = {name: "Tom"}
    let proxy6 = new Proxy(exam2, handler3)
    'name' in proxy6
    // handle has
    // true

    //用于拦截 new 命令。返回值必须为对象。
    let handler4 = {
        construct: function (target, args, newTarget) {
            console.log('handle construct')
            return Reflect.construct(target, args, newTarget)
        }
    }
    class Exam {
        constructor (name) {
            this.name = name
        }
    }
    let ExamProxy = new Proxy(Exam, handler4)
    let proxyObj = new ExamProxy('Tom')
    console.log(proxyObj)
    // handle construct
    // exam {name: "Tom"}

</script>
</body>
</html>
